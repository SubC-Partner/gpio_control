#!/usr/bin/env python3

"""
Control GPIO pins via ROS. Made to be as generic as possible, allowing the same node to be
used in multiple configurations/devices.

@author cst <chris thierauf, christopher.thierauf@tufts.edu>
@version 0.0.1
@license Apache 2.0
@copyright Christopher Thierauf 2020.
This copyright is used to release the code in accordance with the license of this repository.
"""
import sys
import rospy
from src.gpio_control.src.gpio_control_utils import GpioControl, VALID_DEVICES


def setup_parser():
    parser = argparse.ArgumentParser()
    direction_group = parser.add_mutually_exclusive_group()
    direction_group.add_argument('--input', action='store_true', help='Set the pin as an input, '
                                                                      'allowing this node to '
                                                                      'publish the current state '
                                                                      'of the pin. Either --input '
                                                                      'or --output must be used.')
    direction_group.add_argument('--output', action='store_true', help='Set the pin as an output, '
                                                                       'allowing this node to set '
                                                                       'up a subscriber to '
                                                                       'control the state of the '
                                                                       'pin. Either --input or '
                                                                       '--output must be used.')
    pin_id_group = parser.add_mutually_exclusive_group()
    pin_id_group.add_argument('--pin-number', type=int, help='The pin to be manipulated, as a '
                                                             'number. Either pin-number or '
                                                             'pin-name must be specified.')
    pin_id_group.add_argument('--pin-name', type=str, help='The pin to be manipulated, as a '
                                                           'string. Either pin-number or pin-name '
                                                           'must be specified.')

    parser.add_argument('--device', type=str,
                        help='hardware device to use. Valid devices: ' + str(VALID_DEVICES) +
                             '. file-system should support all Linux devices but should be used '
                             'with caution as there are no safety checks, simulated will only '
                             'print to the screen and is not useful in production.')

    parser.add_argument('--rate', type=int, help='Rate at which to run this node. Default: 10.')

    return parser


def check_valid_args(local_args):
    if local_args.pin_name is not None:
        local_pin = local_args.pin_name
    elif local_args.pin_number is not None:
        local_pin = local_args.pin_number
    else:
        rospy.logfatal("What pin should be used? Specify using either --pin-number or --pin-name.")
        sys.exit(1)

    if local_args.device is None:
        rospy.logwarn("No device was specified, so we're assuming nothing and closing.")
        sys.exit(1)
    if not local_args.input and not local_args.output:
        rospy.logerr("Ss this an input or an output? Specify using --input or --output.")
        sys.exit(1)

    return local_pin


if __name__ == '__main__':
    import argparse

    args = setup_parser().parse_args(rospy.myargv()[1:])
    pin = check_valid_args(args)

    rospy.init_node("gpio_control_pin_" + str(pin), anonymous=False)
    rospy.loginfo("Hello! Setting up to control GPIO pin " + str(pin))

    gpio = GpioControl(args.device)
    gpio.add_pin(args.input, pin_num=args.pin_number, pin_name=args.pin_number)
    gpio.spin(args.rate)

    rospy.loginfo("Manager for GPIO " + str(pin) + " stopping. Goodbye!")
